## 종만북 chapter 18. 선형 자료구조
같은 종류의 자료 여러 개를 저장하기 위한 가장 기초적인 자료구조는 배열이다.   
배열과 같은 선형자료구조로 동적 배열과 연결 리스트에 대한 내용 학습.  
배열과 비슷하지만 배열에서 비효율적이거나 할 수 없는 작업들을 효율적으로 할 수 있다.  
  
### 1. 동적 배열  
기존 배열은 처음에 선언 시 크기를 지정해야 하며, 그 이상으로 자료를 집어넣을 수 없다.  
이런 문제를 해결하기 위해 자교의 개수가 변함에 따라 크기가 변경되는 동적배열(dynamic array)가 고안됨.  
내부적으로 배열을 이용하기 때문에 배열이 갖는 다음의 특성을 이어받음.   
  
1. 원소들은 메모리의 연속된 위치에 저장된다.  
2. 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있다.  
  
또한 다음과 같은 추가적인 특성이 있다.    
1. 배열의 크기를 변경하는 연산이 가능. O(N)  
2. 어떤 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 append연산을 지원. 상수시간.  
  
이를 구현하기 위해 동적으로 할당받은 배열을 사용.(new등의 연산으로 할당받은 고정 길이 배열.)  
동적 배열의 크기가 바뀌어야 할 때는 단순히 새 배열을 동적으로 할당받고,   
기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기한다.  
따라서 현재 배열의 크기와 동적으로 할당받은 배열을 가리키는 포인터를  
    
    int size;
    ElementType* array; 
  
와 같은 식으로 저장할 것.  
append를 상수시간에 구현하기 위해 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 미리 할당받아놓은다.  
이미 할당받은 메모리의 크기를 배열의 용량(Capacity),  
실제 원소의 수를 배열의 크기(Size)라 한다.  
  
만약 현재 배열의 크기가 용량보다 작다면.  
`array[size++] = newValue;` 와 같은 식으로 append()를 간단히 구현 가능.  
  
미리 할당해 둔 메모리가 꽉 찬 상태라면 더 큰 새 배열을 동적으로 할당받고  
새 배열에 기존 배열의 내용을 모두 복사한 다음 배열에 대한 포인터를 바꿔치기해야한다.  
이 과정을 '재할당'이라고 부름.  
    
    // 배열 용량이 꽉 차면 재할당받는다.
    if (size == capacity) {
        // 용량을 M만큼 늘린 새 배열을 할당받는다.
        int newCapacity = capacity + M;
        int *newArray = new int[newCapacity];
        // 기존 자료를 복사한다.
        for (int i = 0; i < size; i++) {
            newArray[i] = array[i];
        // 기존 배열을 삭제하고, 새 배열로 바꿔치기한다.
        if (array) delete [] array;
        array = newArray;
        capacity = newCapacity;
    }
    // 배열의 끝에 원소를 삽입한다.
    array[size++] = newValue;
    
#### 재할당 전략
append 호출시마다 선형시간이 걸리는 것은 아니다! 
M을 고정시켜서 늘리는 것은 평균적으로 O(N^2)이 걸림.  
하지만 재할당 할 때 현재 가진 원소의 개수에 비례해서 여유분을 확보한다면 O(N)이 된다.  
즉 append()연산을 N번 수행하는 시간이 O(N)이므로 한번의 append()는 평균적으로 O(1)이 된다.  
C++에서는 STL중 vector가 동적배열임!  
  
append()연산을 여러 번 수행할 때 배열의 최종 크기가 얼마인지 안다면,   
동적 배열의 용량을 미리 늘려둠으로써 재할당에 드는 비용을 없앨 수 있다.  
C++ vector에서 reserve()함수 이용.  

### 2. 연결 리스트
배열 원소들의 순서를 유지하면서 임의의 위치에 원소를 삽입하거나, 임의의 위치에서 원소를 삭제하는 것은 시간이 오래 걸리는 작업이다.  
평균적으로 O(N)  
이와 같은 문제를 해결하기 위한 자료구조가 연결 리스트(Linked List)이다. 특정 위치에서의 삽입과 삭제를 상수 시간에 할 수 있다.  
배열과 아주 다른 형태를 갖고 있다.  
배열은 메모리의 연속된 위치에 각 원소들이 저장되어 있다면,  
연결 리스트는 원소들이 메모리 여기저기 흩어져 있고 각 원소들이 이전과 다음 원소를 가리키는 포인터를 가지고 있는 방식으로 구현된다.
이전과 다음원소 둘 모두를 가리키면 양방향 연결 리스트(Doubly Linked List).  
다음 원소만 가리킨다면 단방향 연결 리스트(Singly Linked List)
예를들어 정수를 담는 연결 리스트는 다음과 같은 노드 구조체를 사용해 구현할 수 있다.  
  
    struct ListNode {
        int element; // 담고있는 원소
        ListNode *prev, *next; // 이전 노드, 다음 노드의 포인터
    };

연결리스트는 첫 번째 노드와 마지막 노드에 대한 포인터를 가지고 있는데, 이들을 각각 머리(head)와 꼬리(tail)라고 부른다.  
  
연결리스트는 배열과 달리 메모리가 연속적이지 않기 때문에 특정 위치의 값을 찾기가 어렵다.  
i번째 노드를 찾고싶다면 head부터 시작해서 하나하나 포인터를 따라 이동해야 한다. 즉 O(N).  
반면 다른 노드들의 순서를 유지하면서 새 노드를 삽입하거나 기존 노드를 삭제하는 작업은 아주 간단하다.  
  
다른 노드들은 그대로 두고, 삽입/삭제할 노드와 이전/이후 노드의 포인터만을 바꾸면 된다.  
포인터만 변경하면 되기 때문에 삽입, 삭제연산은 상수시간이 걸린다.  
  
배열과 연결리스트는 매우 다른 특성을 갖고 있기 때문에 서로 보완하는 관계로 주로 사용된다.  
C++ STL에서 list가 연결리스트를 구현한 것.  
  
연결리스트를 응용하여 한 리스트를 다른 리스트 안에 통째로 삽입하는 잘라붙이기(splicing)연산을 상수시간에 할 수 있다.  
하지만 연결 리스트의 크기를 O(1)에 알기 불가능해진다. 몇 개의 원소가 추가되는지 바로 알 방법이 없기 때문.  
c++의 list는 splice()멤버함수를 통해 연산을 지원함.  
  
또 양방향 연결리스트는 한 번 삭제했던 원소를 제자리에 쉽게 돌려 놓을 수 있다. 삭제한 node에 들어있는 정보는 변하지 않기 때문..
  
    // node 이전/이후 노드의 포인터를 바꿔서 node를 리스트에서 삭제한다.
    void deleteNode(ListNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    // node 이전/이후 노드의 포인터를 바꿔서 자기 자신을 다시 리스트에 삽입한다.
    void recoverNode(ListNode* node) {
        node->prev->next = node;
        node->next->prev = node;
    }
  
이전 노드나 이후 노드또한 삭제된 상태에서 수행하면 구조가 망가지기 때문에 항상 삭제한 순서의 반대로 복구할 때만 사용가능.   
조합 탐색에 응용가능. 춤추는 링크들(Dancing Links)라는 기법이 있다.  
  
#### 동적 배열과 연결 리스트 비교.
가장 큰 차이는 삽입, 삭제, 임의의원소에 접근하는데 드는 시간.  
삽입과 삭제를 할 일이 없거나, 배열의 끝에서만 하면 될 경우는 동적 배열이 거의 항상 더 좋음.  
임의의 원소에 빠르게 접근할 수 있고, 원소들이 메모리에 연속해 배치되어 있어서 CPU 캐시의 효율도 높여줌.  
  
임의의 원소를 접근하는 것이 아니라 모든 원소들을 순회하며 삽입과 삭제를 한다면 연결 리스트가 좋음.  
  
    작업                                 동적 배열       연결 리스트
    -----------------------------------------------------------------
    이전원소 / 다음 원소 찾기            O(1)            O(1)
    맨 뒤에 원소 추가/삭제               O(1)            O(1)
    맨 뒤 이외의 위치에 원소 추가/삭제   O(n)            O(1)
    임의의 위치 원소 찾기                O(1)            O(n)
    크기 구하기                          O(1)            O(n)혹은 구현에 따라 O(1)

### 조세푸스 문제 
N명의 포위당한 병사들이 순서대로 자살.  
한 사람이 자살하면 다음에는 시계방향으로 K번째 살아있는 사람이 자살.  
마지막 두 명은 항복해서 살아남음.  
마지막 두 명 중 하나가 되기 위해서는 첫 번째 병사로부터 몇 자리 떨어진 곳에 있어야 할까?
  
### 입력
첫줄: 테스트 케이스 개수 C(C <= 50)  
각 테스트 케이스는 두 정수 N, K로 주어짐.  
  
### 출력
각 케이스마다 살아남는 두 사람의 번호를 오름차순으로 출력.   
첫 번째로 자살하는 병사의 번호가 1번임. 시계방향으로 번호 증가  

### -----------------------------------------------------------------------
원형으로 연결된 연결 리스트 위에서 이번에 죽을 사람을 가리키는 포인터 kill을 유지하면서,  
포인터가 가리키는 사람을 죽이고 포인터를 K-1번 앞으로 옮기는 방식으로 구현.   
한 사람이 죽을때마다 포인터를 K-1번 옮기기 때문에 전체 시간 복잡도는 O(NK)  
포인터가 리스트의 끝에 도달하면 처음으로 옮겨주는 연산을 통해 원형 리스트를 흉내낸다.  
iterator가 리스트에 끝에 도달하는지 매번 확인하여 끝이면 처음으로 옮겨줌.  
STL에서 list의 크기를 구하는 연산은 O(N). size()를 호출하는 대신 리스트에 포함된 원소의 수를 n에 직접 유지.
  
### 구현
    void josephus(int n, int k) {
        // 리스트 준비
        list<int> survivors;
        for (int i = 1; i <= n; i++) survivors.push_back(i);
        
        // 이번에 죽을 사람을 나타내는 포인터
        list<int>::iterator kill = survivors.begin();
        while (n > 2) {
            // 첫번째 사람이 자살. erase()는 지운 원소의 다음 원소를 반환.
            kill = survivors.erase(kill);
            if(kill == survivors.end()) kill = survivors.begin();
            --n;
            // K-1번 다음 사람으로 옮긴다. (포인터가 이미 한번 이동했으므로)
            for (int i = 0; i < k - 1; i++) {
                ++kill;
                if (kill == survivors.end()) kill = survivors.begin();
            }
        }
        cout << survivors.front() << " " << survivors.back() << '\n';
    }
    
#### 더 빠르게 푸는 법?
K-1번 포인터를 옮기는 대신 (K-1) mod N 번 포인터를 옮기면 된다.  
이렇게 하면 시간복잡도는 O(NK)에서 O(N^2)이 된다. K가 클 때 유용.  
동적계획법으로는 O(N), 시뮬레이션을 한번에 여러 단계씩 해서 O(KlogN)에 수행되는 알고리즘도 있다.  
  
춤추는 링크들을 이용하여 정확히 집합 덮기(Exact cover)문제를 푸는 알고리즘 구현.. 더 읽어보기.

